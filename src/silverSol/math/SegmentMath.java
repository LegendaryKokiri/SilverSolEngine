/* closestPoints() code adapted from https://www.geometrictools.com/GTE/Mathematics/DistSegmentSegment.h
 * David Eberly, Geometric Tools, Redmond WA 98052
 * Copyright (c) 1998-2021
 * Distributed under the Boost Software License, Version 1.0
 * https://www.boost.org/LICENSE_1_0.txt
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
 */

package silverSol.math;

import org.lwjgl.util.vector.Vector2f;
import org.lwjgl.util.vector.Vector3f;

public class SegmentMath {
	
	private static final float EPSILON = 1E-6f;

	public static Vector2f closestPointTo(Vector2f point, Vector2f s1, Vector2f s2) {
		Vector2f disp = Vector2f.sub(s2, s1, null);
		float t = NumberMath.clamp(Vector2f.dot(Vector2f.sub(point, s1, null), disp), 0f, Vector2f.dot(Vector2f.sub(s2, s1, null), disp));
		return Vector2f.add(s1, VectorMath.mul(disp, t, null), null);
	}
	
	public static Vector3f closestPointTo(Vector3f point, Vector3f s1, Vector3f s2) {
		Vector3f segment = Vector3f.sub(s2, s1, null);
		float segmentSq = segment.lengthSquared();
		if(segmentSq < EPSILON) return new Vector3f(s1);
		
		Vector3f direction = segment.normalise(null);
		
		Vector3f displacement = Vector3f.sub(point, s1, null);
		float t = Vector3f.dot(displacement, direction);
		
		if(t * t > segmentSq) return Vector3f.add(s1, segment, null);
		return Vector3f.add(s1, VectorMath.mul(direction, NumberMath.clamp(t, 0f, segment.length()), null), null);
	}
	
	public static Vector3f[] closestPoints(Vector3f P0, Vector3f P1, Vector3f Q0, Vector3f Q1) {
		Vector3f P1mP0 = Vector3f.sub(P1, P0, null);
		Vector3f Q1mQ0 = Vector3f.sub(Q1, Q0, null);
		Vector3f P0mQ0 = Vector3f.sub(P0, Q0, null);
		
		float mA = Vector3f.dot(P1mP0, P1mP0);
		float mB = Vector3f.dot(P1mP0, Q1mQ0);
		float mC = Vector3f.dot(Q1mQ0, Q1mQ0);
		float mD = Vector3f.dot(P1mP0, P0mQ0);
		float mE = Vector3f.dot(Q1mQ0, P0mQ0);
		
		float mF00 = mD;
        float mF10 = mF00 + mA;
        float mF01 = mF00 - mB;
        float mF11 = mF10 - mB;

        float mG00 = -mE;
        float mG10 = mG00 - mB;
        float mG01 = mG00 + mC;
        float mG11 = mG10 + mC;
        
        float s = 0f;
        float t = 0f;
        
        if (mA > 0f && mC > 0f) {
            // Compute the solutions to dR/ds(s0,0) = 0 and
            // dR/ds(s1,1) = 0.  The location of sI on the s-axis is
            // stored in classifyI (I = 0 or 1).  If sI <= 0, classifyI
            // is -1.  If sI >= 1, classifyI is 1.  If 0 < sI < 1,
            // classifyI is 0.  This information helps determine where to
            // search for the minimum point (s,t).  The fij values are
            // dR/ds(i,j) for i and j in {0,1}.

            float[] sValue = new float[2];
            sValue[0] = getClampedRoot(mA, mF00, mF10);
            sValue[1] = getClampedRoot(mA, mF01, mF11);

            int[] classify = new int[2];
            for (int i = 0; i < 2; i++) {
                if (sValue[i] <= 0f) classify[i] = -1;
                else if (sValue[i] >= 1f) classify[i] = 1;
                else classify[i] = 0;
            }

            if (classify[0] == -1 && classify[1] == -1) {
                // The minimum must occur on s = 0 for 0 <= t <= 1.
                s = 0f;
                t = getClampedRoot(mC, mG00, mG01);
            } else if (classify[0] == 1 && classify[1] == 1) {
                // The minimum must occur on s = 1 for 0 <= t <= 1.
                s = 1f;
                t = getClampedRoot(mC, mG10, mG11);
            } else {
                // The line dR/ds = 0 intersects the domain [0,1]^2 in a
                // nondegenerate segment.  Compute the endpoints of that
                // segment, end[0] and end[1].  The edge[i] flag tells you
                // on which domain edge end[i] lives: 0 (s=0), 1 (s=1),
                // 2 (t=0), 3 (t=1).
                int[] edge = new int[2];
                float[][] end = new float[2][2];
                computeIntersection(sValue, classify, edge, end, mB, mF00, mF10);

                // The directional derivative of R along the segment of
                // intersection is
                //   H(z) = (end[1][1]-end[1][0]) *
                //          dR/dt((1-z)*end[0] + z*end[1])
                // for z in [0,1].  The formula uses the fact that
                // dR/ds = 0 on the segment.  Compute the minimum of
                // H on [0,1].
                float[] st = computeMinimumParameters(edge, end, mB, mC, mE, mG00, mG01, mG10, mG11);
                s = st[0];
                t = st[1];
            }
        }  else {
            if (mA > 0f) {
                // The Q-segment is degenerate (Q0 and Q1 are the same
                // point) and the quadratic is R(s,0) = a*s^2 + 2*d*s + f
                // and has (half) first derivative F(t) = a*s + d.  The
                // closest P-point is interior to the P-segment when
                // F(0) < 0 and F(1) > 0.
                s = getClampedRoot(mA, mF00, mF10);
                t = 0f;
            } else if (mC > 0f) {
                s = 0f;
                t = getClampedRoot(mC, mG00, mG01);
            } else {
                s = 0f;
                t = 0f;
            }
        }
        
        return new Vector3f[] {
        	Vector3f.add(VectorMath.mul(P0, 1f-s, null), VectorMath.mul(P1, s, null), null),
        	Vector3f.add(VectorMath.mul(Q0, 1f-t, null), VectorMath.mul(Q1, t, null), null)
        };
	}
	
	private static float getClampedRoot(float slope, float h0, float h1) {
        if (h0 < 0f) {
            if (h1 > 0f) {
                float r = -h0 / slope;
                if (r > 1f) r = 0.5f;
                return r;
            }
            
            return 1f;
        }
        
        return 0f;
    }
	
	private static void computeIntersection(float[] sValue, int[] classify, int[] edge, float[][] end,
			float mB, float mF00, float mF10) {
		if (classify[0] < 0) {
			edge[0] = 0;
			end[0][0] = 0f;
			end[0][1] = mF00 / mB;
			
			if (end[0][1] < 0f || end[0][1] > 1f) end[0][1] = 0.5f;
			
			if (classify[1] == 0) {
				edge[1] = 3;
				end[1][0] = sValue[1];
				end[1][1] = 1f;
			} else {
				edge[1] = 1;
				end[1][0] = 1;
				end[1][1] = mF10 / mB;
				
				if (end[1][1] < 0f || end[1][1] > 1f) end[1][1] = 0.5f;
			}
		} else if (classify[0] == 0) {
			edge[0] = 2;
			end[0][0] = sValue[0];
			end[0][1] = 0f;
			
			if (classify[1] < 0) {
				edge[1] = 0;
				end[1][0] = 0f;
				end[1][1] = mF00 / mB;
				if (end[1][1] < 0f || end[1][1] > 1f) end[1][1] = 0.5f;
			} else if (classify[1] == 0) {
				edge[1] = 3;
				end[1][0] = sValue[1];
				end[1][1] = 1f;
			} else {
				edge[1] = 1;
				end[1][0] = 1f;
				end[1][1] = mF10 / mB;
				
				if (end[1][1] < 0f || end[1][1] > 1f) end[1][1] = 0.5f;
            }
		} else {
			edge[0] = 1;
			end[0][0] = 1f;
			end[0][1] = mF10 / mB;
			if (end[0][1] < 0f || end[0][1] > 1f) end[0][1] = 0.5f;

			if (classify[1] == 0) {
				edge[1] = 3;
				end[1][0] = sValue[1];
				end[1][1] = 1f;
			} else {
				edge[1] = 0;
				end[1][0] = 0f;
				end[1][1] = mF00 / mB;
				if (end[1][1] < 0f || end[1][1] > 1f) end[1][1] = 0.5f;
			}
		}
	}
	

        // Compute the location of the minimum of R on the segment of
        // intersection for the line dR/ds = 0 and the domain [0,1]^2.
    private static float[] computeMinimumParameters(int[] edge, float[][] end,
    		float mB, float mC, float mE, float mG00, float mG01, float mG10, float mG11) {
    	float delta = end[1][1] - end[0][1];
    	float h0 = delta * (-mB * end[0][0] + mC * end[0][1] - mE);
    	
    	if (h0 >= 0f) {
    		if (edge[0] == 0) return new float[]{0f, getClampedRoot(mC, mG00, mG01)};
    		else if (edge[0] == 1) return new float[] {1f, getClampedRoot(mC, mG10, mG11)};
    		else return new float[] {end[0][0], end[0][1]};
    	} else {
    		float h1 = delta * (-mB * end[1][0] + mC * end[1][1] - mE);
    		if (h1 <= 0f) {
    			if (edge[1] == 0) return new float[] {0f, getClampedRoot(mC, mG00, mG01)};
    			else if (edge[1] == 1) return new float[]{1f, getClampedRoot(mC, mG10, mG11)};
    			else return new float[]{end[1][0], end[1][1]};
    		} else {
    			float z = Math.min(Math.max(h0 / (h0 - h1), 0f), 1f);
    			float omz = 1f - z;
    			return new float[] {omz * end[0][0] + z * end[1][0], omz * end[0][1] + z * end[1][1]};
    		}
    	}
    }
	
	public static boolean rayIntersects(Vector3f origin, Vector3f direction, Vector3f s1, Vector3f s2) {
		Vector3f segment = Vector3f.sub(s2, s1, null);
		Vector3f perp = Vector3f.cross(direction, segment, null);
		float perpLengthSq = perp.lengthSquared();
		if(perpLengthSq < EPSILON) return false;
		
		Vector3f dispCross = Vector3f.cross(Vector3f.sub(s1, origin, null), segment, null);
		float dispCrossLengthSq = dispCross.lengthSquared();
		
		float dot = Vector3f.dot(perp, dispCross);
		if(dot * dot - dispCrossLengthSq * perpLengthSq < -EPSILON) return false;
		return true;
	}
	
	public static Vector3f rayIntersection(Vector3f origin, Vector3f direction, Vector3f s1, Vector3f s2) {
		Vector3f segment = Vector3f.sub(s2, s1, null);
		Vector3f perp = Vector3f.cross(direction, segment, null);
		float perpLengthSq = perp.lengthSquared();
		if(perpLengthSq < EPSILON) return null;
		
		Vector3f dispCross = Vector3f.cross(Vector3f.sub(s1, origin, null), segment, null);
		float dispCrossLengthSq = dispCross.lengthSquared();
		
		float dot = Vector3f.dot(perp, dispCross);
		if(dot * dot - dispCrossLengthSq * perpLengthSq < -EPSILON) return null;
		
		float t = (float) (Math.sqrt(dispCrossLengthSq) / Math.sqrt(perpLengthSq));
		
		return Vector3f.add(origin, VectorMath.mul(direction, t, null), null);
	}
	
	public static void main(String[] args) {
		Vector3f[] closest = closestPoints(
				new Vector3f(0f, 3f, 0f), new Vector3f(0f, 1f, 0f),
				new Vector3f(1f, 0f, 1f), new Vector3f(-1f, 0f, 1f));
		
		System.out.println("Closest Points = " + closest[0] + ", " + closest[1]);
	}
	
}
